<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, user-scalable=0, shrink-to-fit=no"
    />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta charset="UTF-8" />
    <meta http-equiv="Expires" content="0" />
    <meta http-equiv="Last-Modified" content="0" />
    <meta http-equiv="Cache-Control" content="no-cache, mustrevalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <title>Konekti Video</title>
    <script
      type="text/javascript"
      src="https://jgomezpe.github.io/konekti/src/konekti.js"
    ></script>
  </head>

  <body>
    <script>
      Konekti.uses("header", "navbar", "canvas");

      class Agent {
        constructor() {}

        init(color, board, time = 20000) {
          this.color = color;
          this.time = time;
          this.size = board.length;
        }

        // Must return a list representing the row and column to put a piece
        // row column
        // | |
        compute(board, time) {
          return [0, 0];
        }
        generateWeightArray(n) {
          const weights = [];
          const middle = Math.floor(n / 2);

          // Fill the array with zeros
          for (let i = 0; i < n; i++) {
            weights.push(new Array(n).fill(1));
          }

          // Set the weights for the corners
          weights[0][0] = weights[0][n - 1] = weights[n - 1][0] = weights[n - 1][n - 1] = 100;

          // Set the weights for the edges
          for (let i = 1; i < n - 1; i++) {
            weights[0][i] = weights[n - 1][i] = weights[i][0] = weights[i][n - 1] = 10;
          }

          // Set the weights for the cells adjacent to the corners
          weights[1][1] = weights[1][n - 2] = weights[n - 2][1] = weights[n - 2][n - 2] = -50;

          // Set the weights for the cells adjacent to the edges
          for (let i = 2; i < n - 2; i++) {
            weights[1][i] = weights[n - 2][i] = weights[i][1] = weights[i][n - 2] = -10;
          }

          // Set the weight for the middle cell
          weights[middle][middle] = 50;

          return weights;
        }

       
      }

      /*
       * A class for board operations (it is not the board but a set of operations over it)
       */
      class Board {
        constructor() {}
        // Initializes a board of the given size. A board is a matrix of size*size of characters ' ', 'B', or 'W'
        init(size) {
          var board = [];
          for (var i = 0; i < size; i++) {
            board[i] = [];
            for (var j = 0; j < size; j++) board[i][j] = " ";
          }
          var m = Math.floor(size / 2) - 1;
          board[m][m] = "W";
          board[m][m + 1] = "B";
          board[m + 1][m + 1] = "W";
          board[m + 1][m] = "B";
          return board;
        }
        // Deep clone of a board the reduce risk of damaging the real board
        clone(board) {
          var size = board.length;
          var b = [];
          for (var i = 0; i < size; i++) {
            b[i] = [];
            for (var j = 0; j < size; j++) b[i][j] = board[i][j];
          }
          return b;
        }

        // Determines if a piece of the 'color' can be set at position 'i', 'j' (row, column, respectively)
        check(board, color, i, j) {
          var size = board.length;
          if (board[i][j] != " ") return false;
          var rcolor = color == "W" ? "B" : "W";
          //left
          var k = j - 1;
          while (k >= 0 && board[i][k] == rcolor) k--;
          if (k >= 0 && Math.abs(k - j) > 1 && board[i][k] == color)
            return true;
          //right
          k = j + 1;
          while (k < size && board[i][k] == rcolor) k++;
          if (k < size && Math.abs(k - j) > 1 && board[i][k] == color)
            return true;
          //up
          k = i - 1;
          while (k >= 0 && board[k][j] == rcolor) k--;
          if (k >= 0 && Math.abs(k - i) > 1 && board[k][j] == color)
            return true;
          //down
          k = i + 1;
          while (k < size && board[k][j] == rcolor) k++;
          if (k < size && Math.abs(k - i) > 1 && board[k][j] == color)
            return true;
          //left-top
          k = i - 1;
          var l = j - 1;
          while (k >= 0 && l >= 0 && board[k][l] == rcolor) {
            k--;
            l--;
          }
          if (
            k >= 0 &&
            l >= 0 &&
            Math.abs(k - i) > 1 &&
            Math.abs(l - j) > 1 &&
            board[k][l] == color
          )
            return true;
          //left-bottom
          k = i + 1;
          l = j - 1;
          while (k < size && l >= 0 && board[k][l] == rcolor) {
            k++;
            l--;
          }
          if (
            k < size &&
            l >= 0 &&
            Math.abs(k - i) > 1 &&
            Math.abs(l - j) > 1 &&
            board[k][l] == color
          )
            return true;
          //right-top
          k = i - 1;
          l = j + 1;
          while (k >= 0 && l < size && board[k][l] == rcolor) {
            k--;
            l++;
          }
          if (
            k >= 0 &&
            l < size &&
            Math.abs(k - i) > 1 &&
            Math.abs(l - j) > 1 &&
            board[k][l] == color
          )
            return true;
          //right-bottom
          k = i + 1;
          l = j + 1;
          while (k < size && l < size && board[k][l] == rcolor) {
            k++;
            l++;
          }
          if (
            k < size &&
            l < size &&
            Math.abs(k - i) > 1 &&
            Math.abs(l - j) > 1 &&
            board[k][l] == color
          )
            return true;
          return false;
        }

        // Computes all the valid moves for the given 'color'
        valid_moves(board, color) {
          var moves = [];
          var size = board.length;
          for (var i = 0; i < size; i++) {
            for (var j = 0; j < size; j++)
              if (this.check(board, color, i, j)) moves.push([i, j]);
          }
          return moves;
        }

        // Determines if a piece of 'color' can be set
        can_play(board, color) {
          var size = board.length;
          var i = 0;
          while (i < size) {
            var j = 0;
            while (j < size && !this.check(board, color, i, j)) j++;
            if (j < size) return true;
            i++;
          }
          return false;
        }

        // Computes the new board when a piece of 'color' is set at position 'i', 'j' (row, column respectively)
        // If it is an invalid movement stops the game and declares the other 'color' as winner
        move(board, i, j, color) {
          var white_move = color == "W";
          var size = board.length;
          if (board[i][j] != " ") return false;
          board[i][j] = color;
          var rcolor = color == "W" ? "B" : "W";
          var flag = false;
          //left
          var k = j - 1;
          while (k >= 0 && board[i][k] == rcolor) k--;
          if (k >= 0 && Math.abs(k - j) > 1 && board[i][k] == color) {
            flag = true;
            k = j - 1;
            while (k > 0 && board[i][k] == rcolor) {
              board[i][k] = color;
              k--;
            }
          }
          //right
          k = j + 1;
          while (k < size && board[i][k] == rcolor) k++;
          if (k < size && Math.abs(k - j) > 1 && board[i][k] == color) {
            flag = true;
            k = j + 1;
            while (k < size && board[i][k] == rcolor) {
              board[i][k] = color;
              k++;
            }
          }
          //up
          k = i - 1;
          while (k >= 0 && board[k][j] == rcolor) k--;
          if (k >= 0 && Math.abs(k - i) > 1 && board[k][j] == color) {
            flag = true;
            k = i - 1;
            while (k >= 0 && board[k][j] == rcolor) {
              board[k][j] = color;
              k--;
            }
          }
          //down
          k = i + 1;
          while (k < size && board[k][j] == rcolor) k++;
          if (k < size && Math.abs(k - i) > 1 && board[k][j] == color) {
            flag = true;
            k = i + 1;
            while (k < size && board[k][j] == rcolor) {
              board[k][j] = color;
              k++;
            }
          }
          //left-top
          k = i - 1;
          l = j - 1;
          while (k >= 0 && l >= 0 && board[k][l] == rcolor) {
            k--;
            l--;
          }
          if (
            k >= 0 &&
            l >= 0 &&
            Math.abs(k - i) > 1 &&
            Math.abs(l - j) > 1 &&
            board[k][l] == color
          ) {
            flag = true;
            k = i - 1;
            l = j - 1;
            while (k >= 0 && l >= 0 && board[k][l] == rcolor) {
              board[k][l] = color;
              k--;
              l--;
            }
          }
          //left-bottom
          var k = i + 1;
          var l = j - 1;
          while (k < size && l >= 0 && board[k][l] == rcolor) {
            k++;
            l--;
          }
          if (
            k < size &&
            l >= 0 &&
            Math.abs(k - i) > 1 &&
            Math.abs(l - j) > 1 &&
            board[k][l] == color
          ) {
            flag = true;
            var k = i + 1;
            var l = j - 1;
            while (k < size && l >= 0 && board[k][l] == rcolor) {
              board[k][l] = color;
              k++;
              l--;
            }
          }
          //right-top
          var k = i - 1;
          var l = j + 1;
          while (k >= 0 && l < size && board[k][l] == rcolor) {
            k--;
            l++;
          }
          if (
            k >= 0 &&
            l < size &&
            Math.abs(k - i) > 1 &&
            Math.abs(l - j) > 1 &&
            board[k][l] == color
          ) {
            flag = true;
            var k = i - 1;
            var l = j + 1;
            while (k >= 0 && l < size && board[k][l] == rcolor) {
              board[k][l] = color;
              k--;
              l++;
            }
          }
          //right-bottom
          var k = i + 1;
          var l = j + 1;
          while (k < size && l < size && board[k][l] == rcolor) {
            k++;
            l++;
          }
          if (
            k < size &&
            l < size &&
            Math.abs(k - i) > 1 &&
            Math.abs(l - j) > 1 &&
            board[k][l] == color
          ) {
            flag = true;
            var k = i + 1;
            var l = j + 1;
            while (k < size && l < size && board[k][l] == rcolor) {
              board[k][l] = color;
              k++;
              l++;
            }
          }
          return flag;
        }

        // Computes the winner in terms of number of pieces in the board
        winner(board, white, black) {
          var size = board.length;
          var W = 0;
          var B = 0;
          for (var i = 0; i < size; i++)
            for (var j = 0; j < size; j++)
              if (board[i][j] == "W") W++;
              else if (board[i][j] == "B") B++;
          var msg = " Pieces count W:" + W + " B:" + B;
          if (W == B) return "Draw " + msg;
          return (W > B ? white : black) + msg;
        }

        // Draw the board on the canvas
        print(board) {
          var size = board.length;
          // Commands to be run (left as string to show them into the editor)
          var grid = [];
          for (var i = 0; i < size; i++) {
            for (var j = 0; j < size; j++)
              grid.push({
                command: "translate",
                y: i,
                x: j,
                commands: [{ command: "-" }, { command: board[i][j] }],
              });
          }

          var commands = {
            r: true,
            x: 1.0 / size,
            y: 1.0 / size,
            command: "fit",
            commands: grid,
          };
          Konekti.client["canvas"].setText(commands);
        }
      }

      /*
       * Player's Code (Must inherit from Agent)
       * This is an example of a rangom player agent
       */
      class RandomPlayer extends Agent {
        constructor() {
          super();
          this.board = new Board();
        }

        compute(board, time) {
          var moves = this.board.valid_moves(board, this.color);
          var index = Math.floor(moves.length * Math.random());
          for (var i = 0; i < 50000000; i++) {} // Making it very slow to test time restriction
          return moves[index];
        }
      }

      class Human extends Agent {
        constructor() {
          super();
          this.board = new Board();
        }

        compute(board, time) {
          var moves = this.board.valid_moves(board, this.color);

          var index = parseInt(prompt("Ingrese movimiento:"));

          return moves[index];
        }
      }

      class bestA extends Agent {
        constructor() {
          super();
          this.board = new Board();
          
          
        }
        

        compute(board, time) {
          
          var warray = this.generateWeightArray(board.length)
          console.log(warray)
          
          var moves = this.board.valid_moves(board, this.color);         
            
          

          if (best ==null){
            return moves[0]
          }


          return best
         

        }

        


        alphabeta(board, depth, alpha, beta, maximizingPlayer, color) {

          const otro = color === "B" ? "W" : "B";

          var valid_moves = this.board.valid_moves(board, color);
          

          if (depth == 0 ) {
            return [null, this.getscore(board, color)];
          }

          
          

          if (maximizingPlayer) {
            var best_move = null;
            var best_score = -Infinity;
            
            for (var move of valid_moves) {
              var new_board = this.applyMove(board, move[0], move[1], color);

              var score = this.alphabeta(new_board, depth - 1, alpha, beta, false, otro)[1];
              
              if (score > best_score) {
                best_score = score;
                best_move = move;
              }
              
              alpha = Math.max(alpha, best_score);
              if (beta <= alpha) {
                break;
              }
            }
            
            return [best_move, best_score];
          } else {
            var best_move = null;
            var best_score = Infinity;
            
            for (var move of valid_moves) {
              var new_board = this.applyMove(board, move[0], move[1], color);
              var score = this.alphabeta(new_board, depth - 1, alpha, beta, true, otro)[1];
              
              if (score < best_score) {
                best_score = score;
                best_move = move;
              }
              
              beta = Math.min(beta, best_score);
              if (beta <= alpha) {
                break;
              }
            }
            return [best_move, best_score];
          }
        }






        bestMove(board, pmoves) {
          var bestMove = pmoves[0];
          var bestScore = 0;
          
          for (const move of pmoves) {
            var nboard = this.applyMove(board, move[0], move[1], this.color);

            const score =
              this.countBw(nboard, this.color) -
              this.countBw(board, this.color);
            
            if (score > bestScore) {
              bestScore = score;
              bestMove = move;
            }
          }
          

          return bestMove;
        }

        

        countBw2(array, letter) {
          let count = 0;

          for (let index = 0; index < array.length; index++) {
            
            for (let j = 0; j < array.length; j++) {

              if (array[index][j] == letter) {
                count += this.wm[index][j];
              }
              
              
            }
            
          }
          return count;
        }
        getscore(array, letter) {
          let count = 0;
          for (const row of array) {
            for (const cell of row) {
              if (cell === letter) {
                count++;
              }
            }
          }
          return count;
        }
        countBw(array, letter) {
          let count = 0;
          for (const row of array) {
            for (const cell of row) {
              if (cell === letter) {
                count++;
              }
            }
          }
          return count;
        }

        getFlip(board, i, j, player) {
          // Comprobamos que la coordenada es válida
          if (
            i < 0 ||
            i >= board.length ||
            j < 0 ||
            j >= board[0].length ||
            board[i][j] !== " "
          ) {
            return 0;
          }

          // Copiamos el tablero para no modificar el original
          const newBoard = board.map((row) => row.slice());

          // Determinamos el color del jugador actual y el contrario
          const color = player === "B" ? "B" : "W";
          const oppositeColor = player === "B" ? "W" : "B";

          // Colocamos la ficha del jugador actual en la coordenada indicada
          newBoard[i][j] = color;

          let flippedCount = 0; // contador de fichas volteadas

          // Buscamos si hay alguna ficha del color contrario que se pueda voltear
          const directions = [    [-1, 0],
            [0, -1],
            [1, 0],
            [0, 1],
            [-1, -1],
            [-1, 1],
            [1, -1],
            [1, 1],
          ];
          for (const [dx, dy] of directions) {
            let x = i + dx;
            let y = j + dy;
            let flipped = false;
            while (
              x >= 0 &&
              x < newBoard.length &&
              y >= 0 &&
              y < newBoard[0].length &&
              newBoard[x][y] === oppositeColor
            ) {
              x += dx;
              y += dy;
              flipped = true;
            }
            if (
              flipped &&
              x >= 0 &&
              x < newBoard.length &&
              y >= 0 &&
              y < newBoard[0].length &&
              newBoard[x][y] === color
            ) {
              x -= dx;
              y -= dy;
              while (newBoard[x][y] === oppositeColor) {
                newBoard[x][y] = color;
                flippedCount++; // aumentamos el contador de fichas volteadas
                x -= dx;
                y -= dy;
              }
            }
          }

          return flippedCount;
        }

      

        applyMove(board, i, j, player) {
          // Comprobamos que la coordenada es válida
          if (
            i < 0 ||
            i >= board.length ||
            j < 0 ||
            j >= board[0].length ||
            board[i][j] !== " "
          ) {
            return null;
          }

          // Copiamos el tablero para no modificar el original
          const newBoard = board.map((row) => row.slice());

          // Determinamos el color del jugador actual y el contrario
          const color = player === "B" ? "B" : "W";
          const oppositeColor = player === "B" ? "W" : "B";

          // Colocamos la ficha del jugador actual en la coordenada indicada
          newBoard[i][j] = color;

          // Buscamos si hay alguna ficha del color contrario que se pueda voltear
          const directions = [
            [-1, 0],
            [0, -1],
            [1, 0],
            [0, 1],
            [-1, -1],
            [-1, 1],
            [1, -1],
            [1, 1],
          ];
          for (const [dx, dy] of directions) {
            let x = i + dx;
            let y = j + dy;
            let flipped = false;
            while (
              x >= 0 &&
              x < newBoard.length &&
              y >= 0 &&
              y < newBoard[0].length &&
              newBoard[x][y] === oppositeColor
            ) {
              x += dx;
              y += dy;
              flipped = true;
            }
            if (
              flipped &&
              x >= 0 &&
              x < newBoard.length &&
              y >= 0 &&
              y < newBoard[0].length &&
              newBoard[x][y] === color
            ) {
              x -= dx;
              y -= dy;
              while (newBoard[x][y] === oppositeColor) {
                newBoard[x][y] = color;
                x -= dx;
                y -= dy;
              }
            }
          }

          return newBoard;
        }
      }

      class MinMaxPlayer2 extends Agent {
        constructor() {
          super();
          this.board = new Board();
        }

        compute(board, time) {
          var moves = this.board.valid_moves(board, this.color);

          return this.bestMove(board,moves);
        }

        bestMove(board, pmoves) {
          var bestMove = pmoves[0];
          var bestScore = 0;
          
          for (const move of pmoves) {
            var nboard = this.applyMove(board, move[0], move[1], this.color);

            const score =
              this.countBw(nboard, this.color) -
              this.countBw(board, this.color);
            
            if (score > bestScore) {
              bestScore = score;
              bestMove = move;
            }
          }
          

          return bestMove;
        }

        countBw(array, letter) {
          let count = 0;
          for (const row of array) {
            for (const cell of row) {
              if (cell === letter) {
                count++;
              }
            }
          }
          return count;
        }

        applyMove(board, i, j, player) {
          // Comprobamos que la coordenada es válida
          if (
            i < 0 ||
            i >= board.length ||
            j < 0 ||
            j >= board[0].length ||
            board[i][j] !== " "
          ) {
            return null;
          }

          // Copiamos el tablero para no modificar el original
          const newBoard = board.map((row) => row.slice());

          // Determinamos el color del jugador actual y el contrario
          const color = player === "B" ? "B" : "W";
          const oppositeColor = player === "B" ? "W" : "B";

          // Colocamos la ficha del jugador actual en la coordenada indicada
          newBoard[i][j] = color;

          // Buscamos si hay alguna ficha del color contrario que se pueda voltear
          const directions = [
            [-1, 0],
            [0, -1],
            [1, 0],
            [0, 1],
            [-1, -1],
            [-1, 1],
            [1, -1],
            [1, 1],
          ];
          for (const [dx, dy] of directions) {
            let x = i + dx;
            let y = j + dy;
            let flipped = false;
            while (
              x >= 0 &&
              x < newBoard.length &&
              y >= 0 &&
              y < newBoard[0].length &&
              newBoard[x][y] === oppositeColor
            ) {
              x += dx;
              y += dy;
              flipped = true;
            }
            if (
              flipped &&
              x >= 0 &&
              x < newBoard.length &&
              y >= 0 &&
              y < newBoard[0].length &&
              newBoard[x][y] === color
            ) {
              x -= dx;
              y -= dy;
              while (newBoard[x][y] === oppositeColor) {
                newBoard[x][y] = color;
                x -= dx;
                y -= dy;
              }
            }
          }

          return newBoard;
        }
      }

      class ManyDisks_Cristian extends MinMaxPlayer2 {
        constructor() {
          super();
          this.board = new Board();
        }

        compute(board, time) {
          var moves = this.board.valid_moves(board, this.color);
          return this.bestMove(board, moves);
        }
      }

      class ManyDisks extends Agent {
        constructor() {
          super();
          this.board = new Board();
        }

        

        compute(board, time) {
          var moves = this.board.valid_moves(board, this.color);
          var bestindex = 0;
          var max_number_of_disk = 0;
          var a_player = this.color === "B" ? "W" : "B";

          for (var i = 0; i < moves.length; i++) {
            var evaluate = moves[i];
            var number_of_disks = 0;

            //Evaluación del símbolo a la izquierda
            //Si la coordenada x actual es 0, se salta el procedimiento
            if (evaluate[0] != 0) {
              //Evaluando si a la izquierda hay una ficha del otro jugador
              if (board[evaluate[0] - 1][evaluate[1]] === a_player) {
                var disks = 1;
                var j = 2;
                while (
                  evaluate[0] - j >= 0 &&
                  board[evaluate[0] - j][evaluate[1]] === a_player
                ) {
                  disks = disks + 1;
                  j = j + 1;
                }
                if (
                  evaluate[0] - j >= 0 &&
                  board[evaluate[0] - j][evaluate[1]] === this.color
                ) {
                  number_of_disks = number_of_disks + disks;
                }
              }
            }

            //Evaluación del símbolo a la derecha
            //Si la coordenada x actual es el tamaño del tablero, se salta el procedimiento
            if (evaluate[0] != this.size - 1) {
              //Evaluando si a la derecha hay una ficha del otro jugador
              if (board[evaluate[0] + 1][evaluate[1]] === a_player) {
                var disks = 1;
                var j = 2;
                while (
                  evaluate[0] + j <= this.size - 1 &&
                  board[evaluate[0] + j][evaluate[1]] === a_player
                ) {
                  disks = disks + 1;
                  j = j + 1;
                }
                if (
                  evaluate[0] + j <= this.size - 1 &&
                  board[evaluate[0] + j][evaluate[1]] === this.color
                ) {
                  number_of_disks = number_of_disks + disks;
                }
              }
            }

            //Evaluación del símbolo arriba
            //Si la coordenada y actual es 0, se salta el procedimiento
            if (evaluate[1] != 0) {
              //Evaluando si arriba hay una ficha del otro jugador
              if (board[evaluate[0]][evaluate[1] - 1] === a_player) {
                var disks = 1;
                var j = 2;
                while (
                  evaluate[1] - j >= 0 &&
                  board[evaluate[0]][evaluate[1] - j] === a_player
                ) {
                  disks = disks + 1;
                  j = j + 1;
                }
                if (
                  evaluate[1] - j >= 0 &&
                  board[evaluate[0]][evaluate[1] - j] === this.color
                ) {
                  number_of_disks = number_of_disks + disks;
                }
              }
            }

            //Evaluación del símbolo abajo
            //Si la coordenada y actual es el tamaño del tablero, se salta el procedimiento
            if (evaluate[1] != this.size - 1) {
              //Evaluando si abajo hay una ficha del otro jugador
              if (board[evaluate[0]][evaluate[1] + 1] === a_player) {
                var disks = 1;
                var j = 2;
                while (
                  evaluate[1] + j <= this.size - 1 &&
                  board[evaluate[0]][evaluate[1] + j] === a_player
                ) {
                  disks = disks + 1;
                  j = j + 1;
                }
                if (
                  evaluate[1] + j <= this.size - 1 &&
                  board[evaluate[0]][evaluate[1] + j] === this.color
                ) {
                  number_of_disks = number_of_disks + disks;
                }
              }
            }

            //Evaluación del símbolo en la esquina superior izquierda
            //Si las coordenadas x y y actuales son 0, se salta el procedimiento
            if (evaluate[0] != 0 && evaluate[1] != 0) {
              //Evaluando si en la esquina superior izquierda hay una ficha del otro jugador
              if (board[evaluate[0] - 1][evaluate[1] - 1] === a_player) {
                var disks = 1;
                var j = 2;
                while (
                  evaluate[0] - j >= 0 &&
                  evaluate[1] - j >= 0 &&
                  board[evaluate[0] - j][evaluate[1] - j] === a_player
                ) {
                  disks = disks + 1;
                  j = j + 1;
                }
                if (
                  evaluate[0] - j >= 0 &&
                  evaluate[1] - j >= 0 &&
                  board[evaluate[0] - j][evaluate[1] - j] === this.color
                ) {
                  number_of_disks = number_of_disks + disks;
                }
              }
            }

            //Evaluación del símbolo en la esquina superior derecha
            //Si la coordenada x actual es el tamaño del tablero y la coordenada y es 0, se salta el procedimiento
            if (evaluate[0] != this.size - 1 && evaluate[1] != 0) {
              //Evaluando si en la esquina superior derecha hay una ficha del otro jugador
              if (board[evaluate[0] + 1][evaluate[1] - 1] === a_player) {
                var disks = 1;
                var j = 2;
                while (
                  evaluate[0] + j <= this.size - 1 &&
                  evaluate[1] - j >= 0 &&
                  board[evaluate[0] + j][evaluate[1] - j] === a_player
                ) {
                  disks = disks + 1;
                  j = j + 1;
                }
                if (
                  evaluate[0] + j <= this.size - 1 &&
                  evaluate[1] - j >= 0 &&
                  board[evaluate[0] + j][evaluate[1] - j] === this.color
                ) {
                  number_of_disks = number_of_disks + disks;
                }
              }
            }

            //Evaluación del símbolo en la esquina inferior izquierda
            //Si la coordenada x actual es 0 y la coordenada y es el tamaño del tablero, se salta el procedimiento
            if (evaluate[0] != 0 && evaluate[1] != this.size - 1) {
              //Evaluando si en la esquina inferior izquierda hay una ficha del otro jugador
              if (board[evaluate[0] - 1][evaluate[1] + 1] === a_player) {
                var disks = 1;
                var j = 2;
                while (
                  evaluate[0] - j >= 0 &&
                  evaluate[1] + j <= this.color - 1 &&
                  board[evaluate[0] - j][evaluate[1] + j] === a_player
                ) {
                  disks = disks + 1;
                  j = j + 1;
                }
                if (
                  evaluate[0] - j >= 0 &&
                  evaluate[1] + j <= this.color - 1 &&
                  board[evaluate[0] - j][evaluate[1] + j] === this.color
                ) {
                  number_of_disks = number_of_disks + disks;
                }
              }
            }

            //Evaluación del símbolo en la esquina inferior derecha
            //Si Si las coordenadas x y y actuales son el tamaño del tablero, se salta el procedimiento
            if (evaluate[0] != this.size - 1 && evaluate[1] != this.size - 1) {
              //Evaluando si en la esquina inferior derecha hay una ficha del otro jugador
              if (board[evaluate[0] + 1][evaluate[1] + 1] === a_player) {
                var disks = 1;
                var j = 2;
                while (
                  evaluate[0] + j <= this.color - 1 &&
                  evaluate[1] + j <= this.color - 1 &&
                  board[evaluate[0] + j][evaluate[1] + j] === a_player
                ) {
                  disks = disks + 1;
                  j = j + 1;
                }
                if (
                  evaluate[0] + j <= this.color - 1 &&
                  evaluate[1] + j <= this.color - 1 &&
                  board[evaluate[0] + j][evaluate[1] + j] === this.color
                ) {
                  number_of_disks = number_of_disks + disks;
                }
              }
            }

            if (number_of_disks >= max_number_of_disk) {
              max_number_of_disk = number_of_disks;
              bestindex = i;
            }
          }

          return moves[bestindex];
        }
      }


      class bestB extends Agent {
        constructor() {
          super();
          this.board = new Board();
          
          
        }
        

        compute(board, time) {
        

          const moves = this.board.valid_moves(board, this.color);         

          moves.sort((a, b) => this.evaluateMove(board, b, this.color) - this.evaluateMove(board, a, this.color));


          console.log(moves)
          return moves[0]

        }



        evaluateMove(board, move, player) {
          const color = player === 'B' ? 'B' : 'W';
          const oppositeColor = player === 'B' ? 'W' : 'B';
          
          const flipped = this.getFlipped(board, move[0], move[1], color);
          if (flipped === null) {
            return -Infinity;
          }
          
          const captured = this.countCaptured(board, flipped);
          const protected1 = this.countProtected1(flipped, color);
          const corners = this.countCorners(move[0], move[1]);
          const edges = this.countEdges(flipped, color);
          const mobility = this.countMobility(flipped, oppositeColor);
          const position = this.getPositionValue(move[0], move[1]);
          
          var score =
            captured * 10 +
            protected1 * 5 +
            corners * 50 +
            edges * 10 +
            mobility * 2 +
            position;
          
          if (score<=0){
            score=1
          }
          return score;
        }

      

      countCaptured(board, flipped) {
        
        let captured = 0;
        for (let i = 0; i < board.length; i++) {
          for (let j = 0; j < board[0].length; j++) {
            if (board[i][j] != flipped[i][j]) {
              captured++;
              if(i==0 || j==0 || i== board[0].length-1 || j== board[0].length-1 ){
                captured++
              }
            }
          }
        }
        return captured;
      }

      countProtected1(flipped, color){

        const oppositeColor = color === "W" ? "B" : "B";
        var moves = this.board.valid_moves(flipped,oppositeColor);  

        var resultBoard = flipped.map((row) => row.slice());

        var abortar = false
        
        for (var move of moves){
          if ((move[0]<=1 && move[1]==flipped[0].length-2) ||(move[0]==flipped[0].length-2 && move[1]==flipped[0].length-2) ||(move[0]==flipped[0].length-2 && move[1]<=1) ||(move[0]<=1 && move[1]<=1)){
            abortar = true
            

            
            break
          }
          var newBoard=this.getFlipped(flipped,move[0],move[1],oppositeColor)
          for (let i = 0; i < newBoard[0].length; i++) {
            for (let j = 0; j < newBoard[0].length; j++) {
              if (newBoard[i][j] != flipped[i][j]) {
                resultBoard[i][j]="O"
              }
              
            }
         }

        }
        var protegidas = this.countAlive(resultBoard,color)
        

        if (abortar){
          protegidas = protegidas - flipped.length*(flipped.length/2)
        }
        return protegidas
      }
      countCorners(i, j, n){

        if ((i==0 && j==n-1) ||(i==n-1 && j==n-1) ||(i==n-1 && j==0) ||(i==0 && j==0)){
          console.log("corner")
          return 1
        }
        return 0
      }
      countEdges(flipped, color){
        return 1
      }
      countMobility(flipped, oppositeColor){
        return 1
      }
      getPositionValue(i, j){
        return 1
      }

      countAlive(array, letter) {
        let count = 0;
        for (const row of array) {
          for (const cell of row) {
            if (cell === letter) {
              count++;
            }
          }
        }
        return count;
      }
      

      getFlipped(board, i, j, player) {
          // Comprobamos que la coordenada es válida
          if (
            i < 0 ||
            i >= board.length ||
            j < 0 ||
            j >= board[0].length ||
            board[i][j] !== " "
          ) {
            return null;
          }

          // Copiamos el tablero para no modificar el original
          const newBoard = board.map((row) => row.slice());

          // Determinamos el color del jugador actual y el contrario
          const color = player === "B" ? "B" : "W";
          const oppositeColor = player === "B" ? "W" : "B";

          // Colocamos la ficha del jugador actual en la coordenada indicada
          newBoard[i][j] = color;

          // Buscamos si hay alguna ficha del color contrario que se pueda voltear
          const directions = [
            [-1, 0],
            [0, -1],
            [1, 0],
            [0, 1],
            [-1, -1],
            [-1, 1],
            [1, -1],
            [1, 1],
          ];
          for (const [dx, dy] of directions) {
            let x = i + dx;
            let y = j + dy;
            let flipped = false;
            while (
              x >= 0 &&
              x < newBoard.length &&
              y >= 0 &&
              y < newBoard[0].length &&
              newBoard[x][y] === oppositeColor
            ) {
              x += dx;
              y += dy;
              flipped = true;
            }
            if (
              flipped &&
              x >= 0 &&
              x < newBoard.length &&
              y >= 0 &&
              y < newBoard[0].length &&
              newBoard[x][y] === color
            ) {
              x -= dx;
              y -= dy;
              while (newBoard[x][y] === oppositeColor) {
                newBoard[x][y] = color;
                x -= dx;
                y -= dy;
              }
            }
          }

          return newBoard;
        }
      
      
      bestMove(board, pmoves) {
        var bestMove = null;
        var bestScore = 0;
        
        for (const move of pmoves) {
          

          const score = this.evaluateMove(board,move,this.color)
          
          if (score > bestScore) {
            bestScore = score;
            bestMove = move;
          }
        }
        

        return bestMove;
      }

      getscore(array, letter) {
          let count = 0;
          for (const row of array) {
            for (const cell of row) {
              if (cell === letter) {
                count++;
              }
            }
          }
          return count;
      }
      




    }



      class minmax extends Agent {
        constructor() {
          super();
          this.board = new Board();
          var f = new bestB()           
       }

       compute(board, time) {
        
        var movi= this.minimaxAlphaBeta(board,4,true,this.color,-Infinity,Infinity).move

        if (movi == null || movi==[]){
          var move = this.board.valid_moves(board, this.color)
          
          
          return this.f.bestMove(board,move)
        }
        
        return movi
      }

      winner(board) {
        let colorCount = 0;
        let opponentCount = 0;

        const oppositeColor = this.color === "B" ? "W" : "B";

        
        for (let i = 0; i < board.length; i++) {
          for (let j = 0; j < board[i].length; j++) {
            if (board[i][j] === this.color) {
              colorCount++;
            } else if (board[i][j] === oppositeColor) {
              opponentCount++;
            }
          }
        }

        return colorCount-opponentCount
      }



      getFlipped(board, i, j, player) {
          // Comprobamos que la coordenada es válida
          if (
            i < 0 ||
            i >= board.length ||
            j < 0 ||
            j >= board[0].length ||
            board[i][j] !== " "
          ) {
            return null;
          }

          // Copiamos el tablero para no modificar el original
          const newBoard = board.map((row) => row.slice());

          // Determinamos el color del jugador actual y el contrario
          const color = player === "B" ? "B" : "W";
          const oppositeColor = player === "B" ? "W" : "B";

          // Colocamos la ficha del jugador actual en la coordenada indicada
          newBoard[i][j] = color;

          // Buscamos si hay alguna ficha del color contrario que se pueda voltear
          const directions = [
            [-1, 0],
            [0, -1],
            [1, 0],
            [0, 1],
            [-1, -1],
            [-1, 1],
            [1, -1],
            [1, 1],
          ];
          for (const [dx, dy] of directions) {
            let x = i + dx;
            let y = j + dy;
            let flipped = false;
            while (
              x >= 0 &&
              x < newBoard.length &&
              y >= 0 &&
              y < newBoard[0].length &&
              newBoard[x][y] === oppositeColor
            ) {
              x += dx;
              y += dy;
              flipped = true;
            }
            if (
              flipped &&
              x >= 0 &&
              x < newBoard.length &&
              y >= 0 &&
              y < newBoard[0].length &&
              newBoard[x][y] === color
            ) {
              x -= dx;
              y -= dy;
              while (newBoard[x][y] === oppositeColor) {
                newBoard[x][y] = color;
                x -= dx;
                y -= dy;
              }
            }
          }

          return newBoard;
        }
      
      
       
       
      minimaxAlphaBeta(board, depth, maximizingPlayer, color, alpha, beta) {
        var oppositeColor = color === 'B' ? 'W' : 'B';

        if (depth === 0 || (!(this.board.can_play(board, color)) && !(this.board.can_play(board, oppositeColor)))) {
          return {
            score: this.winner(board),
            move: null
          };
        }

        if (maximizingPlayer) {
          let maxEval = -Infinity;
          let bestMove = null;
          const possibleMoves = this.board.valid_moves(board, color);
          for (let i = 0; i < possibleMoves.length; i++) {
            const move = possibleMoves[i];
            const newBoard = this.getFlipped(board, move[0], move[1], color);
            const evaluar = this.minimaxAlphaBeta(newBoard, depth - 1, false, oppositeColor, alpha, beta);
            if (evaluar.score > maxEval) {
              maxEval = evaluar.score;
              bestMove = move;
            }
            alpha = Math.max(alpha, evaluar.score);
            if (beta <= alpha) {
              break; // Beta cut-off
            }
          }
          return {
            score: maxEval,
            move: bestMove
          };
        } else {
          let minEval = Infinity;
          let bestMove = null;
          const possibleMoves = this.board.valid_moves(board, color);
          for (let i = 0; i < possibleMoves.length; i++) {
            const move = possibleMoves[i];
            const newBoard = this.getFlipped(board, move[0], move[1], color);
            const evaluar = this.minimaxAlphaBeta(newBoard, depth - 1, true, color, alpha, beta);
            if (evaluar.score < minEval) {
              minEval = evaluar.score;
              bestMove = move;
            }
            beta = Math.min(beta, evaluar.score);
            if (beta <= alpha) {
              break; // Alpha cut-off
            }
          }
          return {
            score: minEval,
            move: bestMove
          };
        }
      }



    }

      /*
       * Environment (Cannot be modified or any of its attributes accesed directly)
       */
      class Environment extends MainClient {
        constructor() {
          super();
          this.board = new Board();
          this.players = {
            // Here we are going to set all the players name : instance of class
            rand: new RandomPlayer(),
            min1: new MinMaxPlayer2(),
            human: new Human(),
            mdd: new ManyDisks(),
            mdc: new ManyDisks_Cristian(),
            bA: new bestA(),
            bB: new bestB(),
            mm: new minmax(),
          };
        }

        // Initializes the game
        init() {
          var white = Konekti.vc("W").value; // Name of competitor with white pieces
          var black = Konekti.vc("B").value; // Name of competitor with black pieces
          var time = 1000 * parseInt(Konekti.vc("time").value); // Maximum playing time assigned to a competitor (milliseconds)
          var size = parseInt(Konekti.vc("size").value); // Size of the reversi board

          this.size = size;
          this.b = this.board.init(size);
          this.board.print(this.b);
          var b1 = this.board.clone(this.b);
          var b2 = this.board.clone(this.b);

          this.white = white;
          this.black = black;
          this.time = { W: time, B: time };
          Konekti.vc("W_time").innerHTML = "" + time;
          Konekti.vc("B_time").innerHTML = "" + time;
          this.player = "W";
          this.winner = "";

          this.players[white].init("W", b1, time);
          this.players[black].init("B", b2, time);
        }

        // Listen to play button
        play() {
          var TIME = 10;
          var x = this;
          var board = x.board;
          x.player = "W";
          Konekti.vc("log").innerHTML = "The winner is...";

          x.init();
          var start = -1;

          function clock() {
            if (x.winner != "") return;
            if (start == -1) setTimeout(clock, TIME);
            else {
              var end = Date.now();
              var ellapsed = end - start;
              var remaining = x.time[x.player] - ellapsed;
              Konekti.vc(x.player + "_time").innerHTML = remaining;
              Konekti.vc((x.player == "W" ? "B" : "W") + "_time").innerHTML =
                x.time[x.player == "W" ? "B" : "W"];

              if (remaining <= 0)
                x.winner =
                  (x.player == "W" ? x.black : x.white) +
                  " since " +
                  (x.player == "W" ? x.white : x.black) +
                  "got time out";
              else setTimeout(clock, TIME);
            }
          }

          function compute() {
            var w = x.player == "W";
            var id = w ? x.white : x.black;
            var nid = w ? x.black : x.white;
            var b = board.clone(x.b);
            start = Date.now();
            var action = x.players[id].compute(b, x.time[x.player]);
            var end = Date.now();
            var flag = board.move(x.b, action[0], action[1], x.player);
            if (!flag) {
              x.winner =
                nid +
                " ...Invalid move taken by " +
                id +
                " on row " +
                action[0] +
                ", column " +
                action[1];
            } else {
              var ellapsed = end - start;
              x.time[x.player] -= ellapsed;
              Konekti.vc(x.player + "_time").innerHTML = "" + x.time[x.player];
              if (x.time[x.player] <= 0) {
                x.winner = nid + " since " + id + " got run of time";
              } else {
                x.player = w ? "B" : "W";
                if (!board.can_play(x.b, x.player)) {
                  x.player = w ? "W" : "B";
                  if (!board.can_play(x.b, x.player))
                    x.winner = board.winner(x.b, x.white, x.black);
                }
              }
            }

            board.print(x.b);
            start = -1;
            if (x.winner == "") setTimeout(compute, TIME);
            else Konekti.vc("log").innerHTML = "The winner is " + x.winner;
          }

          board.print(x.b);
          setTimeout(clock, 1000);
          setTimeout(compute, 1000);
        }
      }

      // Drawing commands
      function custom_commands() {
        return [
          {
            command: " ",
            commands: [
              {
                command: "fillStyle",
                color: { red: 255, green: 255, blue: 255, alpha: 255 },
              },
              {
                command: "polygon",
                x: [0.2, 0.2, 0.8, 0.8],
                y: [0.2, 0.8, 0.8, 0.2],
              },
            ],
          },
          {
            command: "-",
            commands: [
              {
                command: "strokeStyle",
                color: { red: 0, green: 0, blue: 0, alpha: 255 },
              },
              {
                command: "polyline",
                x: [0, 0, 1, 1, 0],
                y: [0, 1, 1, 0, 0],
              },
            ],
          },
          {
            command: "B",
            commands: [
              {
                command: "fillStyle",
                color: { red: 0, green: 0, blue: 0, alpha: 255 },
              },
              {
                command: "polygon",
                x: [0.2, 0.2, 0.8, 0.8],
                y: [0.2, 0.8, 0.8, 0.2],
              },
            ],
          },
          {
            command: "W",
            commands: [
              {
                command: "fillStyle",
                color: { red: 255, green: 255, blue: 0, alpha: 255 },
              },
              {
                command: "polygon",
                x: [0.2, 0.2, 0.8, 0.8],
                y: [0.2, 0.8, 0.8, 0.2],
              },
            ],
          },
        ];
      }

      // Main function using the Konekti infrastructure
      function KonektiMain() {
        var client = new Environment();
        Konekti.header("title", "", "Reversi", 3, {
          class: "w3-black w3-center",
        });
        Konekti.raw("log", "The winner is...");
        // Connects the video with the HTML component
        var btn2 = [
          {
            plugin: "raw",
            setup: [
              "time",
              "",
              {
                tag: "input",
                width: "150px",
                class: "w3-bar-item w3-input w3-border w3-round-xlarge",
                placeholder: "&#xf252; Time (secs)",
                value: "60",
                style:
                  "margin-top:2px;margin-bottom:2px;font-family: FontAwesome, Arial, Verdana, sans-serif;",
              },
            ],
          },
          {
            plugin: "raw",
            setup: [
              "size",
              "",
              {
                tag: "input",
                width: "150px",
                class: "w3-bar-item w3-input w3-border w3-round-xlarge",
                placeholder: "&#xf00a; Size",
                value: "8",
                style:
                  "margin-top:2px;margin-bottom:2px;font-family: FontAwesome, Arial, Verdana, sans-serif;",
              },
            ],
          },
          {
            plugin: "raw",
            setup: [
              "W",
              "",
              {
                tag: "input",
                width: "150px",
                class: "w3-bar-item w3-input w3-border w3-round-xlarge",
                placeholder: "&#xf10c; White",
                value: "mm",

                style:
                  "margin-top:2px;margin-bottom:2px;font-family: FontAwesome, Arial, Verdana, sans-serif;",
              },
            ],
          },
          {
            plugin: "raw",
            setup: [
              "W_time",
              "&#xf252; White",
              {
                width: "150px",
                class: "w3-bar-item w3-input w3-border w3-round-xlarge",
                style:
                  "margin-top:2px;margin-bottom:2px;font-family: FontAwesome, Arial, Verdana, sans-serif;",
              },
            ],
          },
          {
            plugin: "raw",
            setup: [
              "B",
              "",
              {
                tag: "input",
                width: "150px",
                class: "w3-bar-item w3-input w3-border w3-round-xlarge",
                placeholder: "&#xf111; Black",
                value: "rand",
                style:
                  "margin-top:2px;margin-bottom:2px;font-family: FontAwesome, Arial, Verdana, sans-serif;",
              },
            ],
          },
          {
            plugin: "raw",
            setup: [
              "B_time",
              "&#xf252; Black",
              {
                width: "150px",
                class: "w3-bar-item w3-input w3-border w3-round-xlarge",

                style:
                  "margin-top:2px;margin-bottom:2px;font-family: FontAwesome, Arial, Verdana, sans-serif;",
              },
            ],
          },
          {
            plugin: "btn",
            setup: [
              "play",
              "fa-play",
              "",
              null,
              { title: "Cara", class: "w3-right" },
            ],
          },
        ];
        Konekti.navbar(
          "navbar2",
          btn2,
          { client: "client", method: "play" },
          { class: "w3-black w3-medium" }
        );
        // Connecting the canvas to the HTML component
        var commands = custom_commands();
        Konekti.canvas("canvas", {}, commands, {
          width: "100%",
          height: "fit",
        });
      }
    </script>
  </body>
</html>
